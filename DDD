Perfect — now we can think about this system using **Domain-Driven Design (DDD)**. Let’s map your dental home booking system into **Aggregates, Entities, Value Objects, Events, and Commands**.

---

## **1️⃣ Aggregate Root**

* **Definition:** The main entry point for a consistency boundary. Other entities within the aggregate are only modified through the root.
* **Candidate:** `Appointment`

  * Why?

    * All operations (adding services, assigning dentist, completing appointment) should happen **through Appointment**.
    * Appointment encapsulates the booking state, services, and treatments.

---

## **2️⃣ Entities**

Entities have **identity** (a unique ID) and mutable state.

| Entity               | Notes                                                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `AppointmentService` | Each booked service instance; belongs to an Appointment. Has snapshot fields (`name`, `duration`, `price`) and identity. |
| `Treatment`          | Linked to AppointmentService; has identity (`id`) and details.                                                           |
| `User`               | Patients and staff; identity via `id`. Optional to include inside aggregate depending on usage.                          |

> `Appointment` itself is an **entity** and **aggregate root**, because it owns `AppointmentServices` and `Treatments`.

---

## **3️⃣ Value Objects (VOs)**

VOs are immutable objects that describe something by **value**, not identity.

| VO            | Notes                                                                                       |
| ------------- | ------------------------------------------------------------------------------------------- |
| `Money`       | Could encapsulate `amount` + `currency`. Used for `base_price` and `final_price`.           |
| `Duration`    | Could represent `minutes` for service or buffer.                                            |
| `TimeSlot`    | Start & end time. Could calculate conflicts or overlaps.                                    |
| `PatientInfo` | Name, email, phone snapshot (optional if you don’t want full User entity inside aggregate). |

---

## **4️⃣ Domain Events**

Events describe **something that has happened** in the domain. Useful for triggering side effects.

| Event                       | Notes                                                |
| --------------------------- | ---------------------------------------------------- |
| `AppointmentCreated`        | Triggered when an appointment is booked.             |
| `ServiceAddedToAppointment` | Triggered when a service is added to an appointment. |
| `AppointmentCompleted`      | Triggered when appointment is completed.             |
| `ServicePriceAdjusted`      | Triggered when final\_price is modified manually.    |
| `AppointmentCanceled`       | Triggered when appointment is canceled.              |

> These events can be published to other subsystems (e.g., notifications, billing, calendar).

---

## **5️⃣ Commands**

Commands are **intentions to perform an action** on the aggregate.

| Command                   | Notes                                                                         |
| ------------------------- | ----------------------------------------------------------------------------- |
| `CreateAppointment`       | Input: patient\_id, list of services, date/time.                              |
| `AddServiceToAppointment` | Input: appointment\_id, service\_catalog\_id, optional discount/final\_price. |
| `CompleteAppointment`     | Input: appointment\_id, optional dentist\_id, completion notes.               |
| `CancelAppointment`       | Input: appointment\_id, cancellation\_reason.                                 |
| `AdjustServicePrice`      | Input: appointment\_service\_id, new\_final\_price.                           |

> Commands are handled by **the Appointment aggregate**, which applies the business rules and generates domain events.

---

## **6️⃣ Aggregate Structure Example**

```
Appointment (Aggregate Root)
 ├─ id
 ├─ patient_id
 ├─ dentist_id (nullable)
 ├─ status
 ├─ appointment_date
 ├─ appointment_time
 ├─ completion_notes
 ├─ cancellation_reason
 └─ services: List<AppointmentService>
        ├─ id
        ├─ catalog_id
        ├─ name
        ├─ description
        ├─ duration
        ├─ buffer
        ├─ base_price
        ├─ final_price
        ├─ is_initial
        └─ treatments: List<Treatment>
              ├─ id
              └─ detail
```

---

### **7️⃣ How DDD Helps Here**

* Encapsulation: Only `Appointment` can add/remove `AppointmentService` or treatments.
* Consistency: Total price, duration, and status logic reside inside the aggregate.
* Event-driven: Other subsystems (notifications, billing, calendar) react to events.
* Flexible: Discounts, manual adjustments, or dentist assignment can be applied via commands.

---

If you want, I can **write a TypeScript or Python DDD-style `Appointment` aggregate class** showing **methods for commands, handling events, and computing totals**, which would be a concrete implementation of this design.

Do you want me to do that?


Exactly — in DDD terms, **Service Catalog is not part of the Appointment aggregate**, and here’s why:

---

## **1️⃣ Service Catalog is a Separate Aggregate**

* **Role:** It represents available services in the system — metadata for scheduling, pricing, and description.
* **Reason it’s not inside Appointment aggregate:**

  * It’s **shared and independent** — many appointments reference the same catalog entry.
  * Changes in the catalog (price, duration) **shouldn’t directly mutate past appointments**.
  * Appointment only **stores a snapshot** of relevant fields (name, description, duration, base\_price, buffer) in `AppointmentService`.

> In DDD: `ServiceCatalog` is an **aggregate root** on its own, and `Appointment` only references it by `catalog_id`.

---

### **ServiceCatalog Aggregate**

```
ServiceCatalog (Aggregate Root)
 ├─ id
 ├─ name
 ├─ description
 ├─ duration
 ├─ buffer
 ├─ base_price
 ├─ created_at
 └─ updated_at
```

* Can have commands like:

  * `CreateService`
  * `UpdateService`
  * `DeactivateService`

* Can publish events like:

  * `ServiceCreated`
  * `ServiceUpdated`

* Appointment references `ServiceCatalog` by **id** but never modifies it.

---

## **2️⃣ Users as Aggregate Root**

* Yes — `User` is also an **aggregate root**, separate from Appointment.
* **Why:**

  * It manages **identity, authentication, roles, and permissions**.
  * Appointment only references `patient_id` and optionally `dentist_id`; it **does not manage user state**.

### **User Aggregate**

```
User (Aggregate Root)
 ├─ id
 ├─ name
 ├─ email
 ├─ phone
 ├─ role
 ├─ password_hash / auth info
 ├─ permissions / roles
 └─ created_at, updated_at
```

* Commands:

  * `RegisterUser`
  * `AssignRole`
  * `ChangePassword`
* Events:

  * `UserRegistered`
  * `RoleAssigned`
  * `UserUpdated`

---

## **3️⃣ Summary of Aggregate Boundaries**

| Aggregate Root | Purpose / Boundary                                            |
| -------------- | ------------------------------------------------------------- |
| Appointment    | Manages booking, services (instances), treatments, status.    |
| ServiceCatalog | Manages available services metadata, duration, buffer, price. |
| User           | Manages patients and staff identity, roles, and auth.         |

> **Key DDD principle:** Aggregates communicate by **IDs and events**, not by embedding each other. Appointment keeps **snapshots** of service info to avoid direct coupling to ServiceCatalog.

---

If you want, I can **draw a DDD Aggregate diagram** showing:

* `Appointment` aggregate with `AppointmentService` and `Treatment` entities
* `ServiceCatalog` as a separate aggregate
* `User` as a separate aggregate
* Relationships via IDs and domain events

This will make the DDD boundaries very clear.

Do you want me to make that diagram?
